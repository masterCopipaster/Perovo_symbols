encoding  utf-8
layout symbols_cave
 
	code metapost
	
	    beginpattern(pattern_u_limestone);
    	    pickup PenC;
    	    p:=(.5u,0) -- (0,0) -- (0,.5u) -- (u,.5u) -- (u,0) -- (.5u,0) -- (.5u,-.5u);
    	    draw p;
    	    draw p shifted (u,u);
    	    patternxstep(u);
    	    patternystep(u);
        endpattern;

        def a_u_limestone (expr Path) =
            T:=identity;
            thclean Path;
            thfill Path withpattern pattern_u_limestone;
        enddef;
		
		beginpattern(pattern_u_sandstone);
            pickup PenC;
            draw (.5u,.33u); draw (.5u,.66u); draw (.5u,-.33u); draw (.5u,-.66u);
            draw (u,.5u);
            draw (1.5u,.33u); draw (1.5u,.66u); draw (1.5u,-.33u); draw (1.5u,-.66u);
            draw (0,-.5u);			
			p:=(u,0) -- (0,0) -- (0,u) -- (2u,u) -- (2u,0) -- (u,0) -- (u,-u);
    	    draw p;
    	    draw p shifted (2u,2u);
    	    patternxstep(2u);
    	    patternystep(2u);
        endpattern;

        def a_u_sandstone (expr Path) =
            T:=identity;
            thclean Path;
            thfill Path withpattern pattern_u_sandstone;
        enddef;
		
		beginpattern(pattern_u_breccia);
            pickup PenC;
			q:=(-.15u,-.1u)--(.15u,-.1u)--(0,.15u)--cycle;
			draw q rotated 20 shifted (.6u,.4u);
			draw q rotated 40 shifted (1.4u,.6u);
			draw q rotated 40 shifted (0.4u,-.4u);
			draw q rotated 20 shifted (1.6u,-.6u);		
			p:=(u,0) -- (0,0) -- (0,u) -- (2u,u) -- (2u,0) -- (u,0) -- (u,-u);
    	    draw p;
    	    draw p shifted (2u,2u);
    	    patternxstep(2u);
    	    patternystep(2u);
        endpattern;

        def a_u_breccia (expr Path) =
            T:=identity;
            thclean Path;
            thfill Path withpattern pattern_u_breccia;
        enddef;
		
		beginpattern(pattern_u_tufa);
    		pickup PenC;
    		p:=(-.5u,0){down} .. {up}(-.1666u,0){down}..
        		{up}(.1666u,0){down} .. {up}(.5u,0);
    		draw p;
    		draw p shifted (0.5u,0.2u);
    		patternxstep(1.0u);
    		patternystep(0.4u);
            patterntransform(identity rotated 180);
		endpattern;

        def a_u_tufa (expr Path) =
            T:=identity;
            thclean Path;
            thfill Path withpattern pattern_u_tufa;
        enddef;

		def l_u_slope_sheer (expr P) =
		  T:=identity;
		  cas := 0;
		  dlzka := arclength P;
		  mojkrok:=adjust_step(dlzka, 1.5u);
		  pickup PenD;
		  forever:
		    t := arctime cas of P;
		    mark_ (P,t,1.2u);
		    cas := cas + mojkrok;
		    exitif cas > dlzka + (mojkrok / 3); % for rounding errors
		  endfor;
		  pickup PenC;
		  thdraw P;
		enddef;
	
	
		def l_u_fence (expr P) =
  		  if ATTR__elevation:
  		    T:=identity;
  		    cas := 0;
  		    dlzka := arclength P;
  		    mojkrok:=adjust_step(dlzka, 1u);
  		    pickup PenD;
  		    pair tmppoint;
  		    tmph := 1 / Scale * 72 / 2.54;  % 1 m height
  		    tmppoint:=(point 0 of P) +(0,tmph);
 		    forever:
		      t := arctime cas of P;
  		      draw point t of P -- (point t of P)+(0,tmph) withpen PenD;
  		      if cas > 0:
  		        draw tmppoint -- (point t of P)+(0,tmph) withpen PenC;
  		        tmppoint := (point t of P)+(0,tmph);
  		      fi;
   		      cas := cas + mojkrok;
   		      exitif cas > dlzka + (mojkrok / 3); % for rounding errors
  		    endfor;
 		  else:
  		    T:=identity;
  		    cas := 0;
   		    pair coord;
  		    sq_size:=0.12u;
  		    dlzka := arclength P;
 		    mojkrok:=adjust_step(dlzka, u);
 		    pickup PenD;
 		    forever:
  		      t := arctime cas of P;
  		      coord := point t of P;
              draw coord+(-sq_size,-sq_size) -- coord+(sq_size,sq_size) withpen PenD;
              draw coord+(sq_size,-sq_size) -- coord+(-sq_size,sq_size) withpen PenD;
  		      cas := cas + mojkrok;
  		      exitif cas > dlzka + (mojkrok / 3); % for rounding errors
 		    endfor;
  		    pickup PenC;
  		    thdraw P;
 		  fi;
		enddef;
		initsymbol("l_u_fence");
		
		def l_u_gour_rim (expr P) =
          T:=identity;
          cas := 0;
          dlzka := arclength P;
          mojkrok:=adjust_step(dlzka, .5u);
          if (cycle P) and (dlzka < 2.5u):   % make at least 5 curls on a cyclic path
            mojkrok := dlzka/5;
          fi;
          pickup PenC;
          t1:=0;
          forever:
            t2 := arctime (cas + mojkrok) of P;
            thdraw (point t1 of P){dir (angle(thdir(P,t1)) + 60)} ..
                   {dir (angle(thdir(P,t2)) - 60)}(point t2 of P);
            cas := cas + mojkrok;
            exitif cas > dlzka + (mojkrok / 3); % for rounding errors
            t1:=t2;
          endfor;
		enddef;
		initsymbol("l_u_gourrim");
		
		def p_u_stratainclined (expr pos,theta,sc,al) =
			U:=(.5u,.5u);
			T:=identity aligned al rotated theta scaled sc shifted pos;
			pickup PenC;
			p:=(-.5u,.15u)--(.1u,.15u)..(.24u,.03u)--(.45u,.03u)--(.45u,.08u)--(.5u,.08u)--(.5u,-.08u)
			--(.45u,-.08u)--(.45u,-.04u)--(.24u,-.04u)..(.1u,-.15u)--(-.5u,-.15u)--cycle;
			thdraw p;
			thfill p withcolor green;
		enddef;
		initsymbol("p_u_stratainclined");
		
		def l_u_rockfall (expr P) =
			T:=identity;
			cas := 0;
			dlina := arclength P;
			if dlina > 0:
				shag:=adjust_step(dlina, 0.45u);
				pickup PenB;
				forever:
					t1 := arctime (cas) of P;
					t2 := arctime (cas + shag*1/3) of P;
					t3 := arctime (cas + shag*2/3) of P;
					t4 := arctime (cas + shag) of P;
					p := (point t1 of P) --
						 ((point t2 of P) + .25u * unitvector(thdir(P,t2) rotated 90)) --
						 ((point t3 of P) + .25u * unitvector(thdir(P,t3) rotated -90)) --
						 (point t4 of P) --
						 cycle;
					thfill p withcolor (0.98 red + 0.93 green + 0.68 blue);	 
					q := (point t1 of P) --
						 ((point t2 of P) + .25u * unitvector(thdir(P,t2) rotated 90)) --
						 ((point t3 of P) + .25u * unitvector(thdir(P,t3) rotated -90)) --
						 (point t4 of P);
					thdraw q withcolor red;
					cas := cas + shag;
					exitif cas > dlina - (2*shag/3); % for rounding errors
				endfor;
			fi;
		enddef;
		initsymbol("l_u_rockfall");
	
		def s_northarrow (expr rot) =
            valscal=1.0; % scale your north arrow here
            decl:=MagDecl; 
            T:=identity;
            picture tmp_pic;
            tmp_pic = image (
                          pickup pencircle scaled .3;
                          thfill fullcircle scaled 4cm withcolor 1white;
                          thdraw fullcircle scaled 3.1cm;
                          thdraw fullcircle scaled 4.05cm;
                          pickup pencircle scaled .1;
                          thdraw fullcircle scaled 3cm;
                          thdraw fullcircle scaled 4cm;
                          pickup pencircle scaled .2;
                          thdraw (dir(45)*2.025cm)--(dir(45)*3.7cm);
                          thdraw (dir(135)*2.025cm)--(dir(135)*3.7cm);
                          thdraw (dir(225)*2.025cm)--(dir(225)*3.7cm);
                          thdraw (dir(315)*2.025cm)--(dir(315)*3.7cm);
                          pickup pencircle scaled .1;
                          for whereto=0 step 15 until 345:
                            thdraw dir(whereto)*.65cm--dir(whereto)*.9cm;
                            thdraw dir(whereto)*1.4cm--dir(whereto)*1.5cm;
                          endfor;
                          for whereto=0 step 5 until 355:
                            thdraw dir(whereto)*.65cm--dir(whereto)*.8cm;
                            thdraw dir(whereto)*1.45cm--dir(whereto)*1.5cm;
                          endfor; 
                          for whereto=0 step 1 until 359:
                            thdraw dir(whereto)*1.94cm--dir(whereto)*2cm;
                          endfor; 
                          pickup pencircle scaled 1;
                          thdraw fullcircle scaled 1cm;
                          thdraw fullcircle scaled 1.1cm;
                          thdraw fullcircle scaled 1.3cm withpen pencircle scaled .3;
                          vald=90-decl;
                          texrot=0-decl;
                          drawarrow(dir(vald)*-2cm--dir(vald)*2cm) withpen pencircle scaled .2;
                          if (MagDecl <> 0): thdraw image(label.top(btex $mg$ etex, (0,0)) scaled .5 rotated texrot;) shifted (dir(vald)*2.04cm); fi;                                               
                          thfill (1.06cm,1.06cm)--(0,.2cm)--(-1.06cm,1.06cm)--(-.2cm,0)--(-1.06cm,-1.06cm)--(0,-.2cm)--(1.06cm,-1.06cm)--(.2cm,0)--cycle;
                          thfill (-.2cm,.2cm)--(0,2cm)--(0,0)--cycle;
                          thfill (.2cm,-.2cm)--(0,-2cm)--(0,0)--cycle;
                          thfill (.2cm,.2cm)--(2cm,0)--(0,0)--cycle;
                          thfill (-.2cm,-.2cm)--(-2cm,0)--(0,0)--cycle;
                          thfill (.2cm,.2cm)--(-0,2cm)--(0,0)--cycle withcolor 1white;
                          thfill (.2cm,-.2cm)--(2cm,0)--(0,0)--cycle withcolor 1white;
                          thfill (-.2cm,-.2cm)--(0,-2cm)--(0,0)--cycle withcolor 1white;
                          thfill (-.2cm,.2cm)--(-2cm,0)--(0,0)--cycle withcolor 1white;                                     
                          pickup pencircle scaled .2;
                          thdraw (-.2cm,.2cm)--(0,2cm)--(.2cm,.2cm)--(2cm,0cm)--(.2cm,-.2cm)--(0,-2cm)--(-.2cm,-.2cm)--(-2cm,0)--cycle;
                          thfill fullcircle scaled .56cm withcolor 1white;
                          pickup pencircle scaled .1;
                          thdraw (.28cm,0)..(0,.28cm)..(-.28cm,0)..(0,-.28cm)..cycle;
                          pickup pencircle scaled .4;
                          thdraw (.2cm,0)..(0,.2cm)..(-.2cm,0)..(0,-.2cm)..cycle;
                          if (MagDecl = 0): label.bot(btex $Nmag$ etex, (0,2.6cm)); else: label.bot(btex $N$ etex, (0,2.6cm)); fi;
                          label.lft(btex $E$ etex, (2.6cm,0));
                          label.rt(btex $W$ etex, (-2.6cm,0));
                          label.top(btex $S$ etex, (0,-2.6cm));
            );
            thdraw tmp_pic scaled valscal rotatedaround(origin, -rot);
		enddef;

		def s_scalebar (expr l, units, txt) =
			begingroup
				interim warningcheck:=0;
				tmpl:=l / Scale * cm * units / 2;
				tmpx:=l / Scale * cm * units / 5;
				tmph:=5bp; % bar height
			endgroup;
			pickup PenC;
			draw (-tmpl,0)--(tmpl,0)--(tmpl,-tmph)--(-tmpl,-tmph)--cycle;
			p:=(0,0)--(tmpx,0)--(tmpx,-tmph)--(0,-tmph)--cycle;
			for i:=-2.5 step 2 until 2:
				fill p shifted (i * tmpx,0);
			endfor;
			begingroup
				interim labeloffset:=3.5bp;
				for i:=0 step (l/5) until (l-1):
					tmpx:=tmpl * (i * 2 / l - 1);
					label.bot(thTEX(decimal (i)),(tmpx,-tmph));
				endfor;
				label.bot(thTEX(decimal (l) & "\thinspace" & txt),(tmpl,-tmph));
				label.top(thTEX("M 1 : " & decimal round(Scale*100)),(0,0));
			endgroup;
		enddef;
		
		def p_u_fossil (expr pos,theta,sc,al)=
			U:=(0,0);
			T:=identity aligned al rotated theta scaled sc shifted pos;
			pickup PenB;
			p := (-.05u, 0) .. (.085u, 0) .. (-.15u, 0) .. (.26u, 0) .. (-.45u, 0) .. (.63u, 0) -- (.63u, 0) .. (.47u, .05u) .. (0.32u, 0);
			thdraw p;
		enddef;
		initsymbol("p_u_fossil");
				
	endcode

  symbol-set AUT
  color map-fg [98 93 68]

endlayout

text ru "line fault" "разлом"
text ru "point danger" "опасность"
text ru "point water-drip" "водокап"
text ru "point bones" "останки животных"
text ru "point mudcrack" "глина растрескавшаяся"

text ru "line u:rockfall" "обвал"
text ru "line u:fence" "ограждение"
text ru "line u:gour_rim" "край гура"
text ru "line u:slope_sheer" "склон отвесный"

text ru "area u:breccia" "брекчия"
text ru "area u:flowstone" "натёки"
text ru "area u:limestone" "известняк"
text ru "area u:sandstone" "песчаник"
text ru "area u:tufa" "туф"

text ru "point u:clay_coating" "глиняная пыль"
text ru "point u:clay_pouring" "глиняный наплыв"
text ru "point u:element" "элемент залегания"
text ru "point u:fossil" "окаменелость"
text ru "point u:manganese_bloom" "марганцевый налет"
text ru "point u:ocher_bloom" "охристый налёт"
text ru "point u:mirror" "зеркало скольжения"
text ru "point u:mirror_down" "зеркало опущенного блока"
text ru "point u:mirror_up" "зеркало поднятого блока"
text ru "point u:organ_pipe" "органная труба"
